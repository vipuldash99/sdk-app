"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PruneProgrammer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var ExpressionFactory_1 = require("../factories/ExpressionFactory");
var IdentifierFactory_1 = require("../factories/IdentifierFactory");
var MetadataCollection_1 = require("../factories/MetadataCollection");
var MetadataFactory_1 = require("../factories/MetadataFactory");
var TypeFactory_1 = require("../factories/TypeFactory");
var Metadata_1 = require("../metadata/Metadata");
var FeatureProgrammer_1 = require("./FeatureProgrammer");
var IsProgrammer_1 = require("./IsProgrammer");
var FunctionImporeter_1 = require("./helpers/FunctionImporeter");
var PruneJoiner_1 = require("./helpers/PruneJoiner");
var UnionExplorer_1 = require("./helpers/UnionExplorer");
var decode_union_object_1 = require("./internal/decode_union_object");
var PruneProgrammer;
(function (PruneProgrammer) {
    function generate(project, modulo) {
        var importer = new FunctionImporeter_1.FunctionImporter();
        return FeatureProgrammer_1.FeatureProgrammer.generate(project, CONFIG(project, importer), importer, function (collection) {
            var isFunctors = IsProgrammer_1.IsProgrammer.generate_functors(project, importer)(collection);
            var isUnioners = IsProgrammer_1.IsProgrammer.generate_unioners(project, importer)(collection);
            return __spreadArray(__spreadArray(__spreadArray([], __read(importer.declare(modulo)), false), __read(isFunctors.filter(function (_, i) {
                return importer.hasLocal("$io".concat(i));
            })), false), __read(isUnioners.filter(function (_, i) {
                return importer.hasLocal("$iu".concat(i));
            })), false);
        });
    }
    PruneProgrammer.generate = generate;
    var decode = function (project, importer) {
        return function (input, meta, explore) {
            var e_1, _a, e_2, _b;
            if (filter(meta) === false)
                return typescript_1.default.factory.createBlock([]);
            var unions = [];
            var _loop_1 = function (tuple) {
                unions.push({
                    type: "tuple",
                    is: function () {
                        return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                            var partial = Metadata_1.Metadata.initialize();
                            partial.tuples.push(tuple);
                            return partial;
                        })(), explore, []);
                    },
                    value: function () {
                        return decode_tuple(project, importer)(input, tuple, explore);
                    },
                });
            };
            try {
                for (var _c = __values(meta.tuples.filter(function (t) {
                    return t.some(function (e) { var _a; return filter((_a = e.rest) !== null && _a !== void 0 ? _a : e); });
                })), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var tuple = _d.value;
                    _loop_1(tuple);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (meta.arrays.filter(filter).length)
                unions.push({
                    type: "array",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isArray(input); },
                    value: function () {
                        return explore_arrays(project, importer)(input, meta.arrays, __assign(__assign({}, explore), { from: "array" }), []);
                    },
                });
            if (meta.natives.length) {
                var _loop_2 = function (native) {
                    unions.push({
                        type: "native",
                        is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, native); },
                        value: function () { return typescript_1.default.factory.createReturnStatement(); },
                    });
                };
                try {
                    for (var _e = __values(meta.natives), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var native = _f.value;
                        _loop_2(native);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (meta.sets.length)
                unions.push({
                    type: "set",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Set"); },
                    value: function () { return typescript_1.default.factory.createReturnStatement(); },
                });
            if (meta.maps.length)
                unions.push({
                    type: "map",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Map"); },
                    value: function () { return typescript_1.default.factory.createReturnStatement(); },
                });
            if (meta.objects.length)
                unions.push({
                    type: "object",
                    is: function () {
                        return ExpressionFactory_1.ExpressionFactory.isObject(input, {
                            checkNull: true,
                            checkArray: false,
                        });
                    },
                    value: function () {
                        return explore_objects(importer)(input, meta, __assign(__assign({}, explore), { from: "object" }));
                    },
                });
            var converter = function (v) {
                return typescript_1.default.isReturnStatement(v) || typescript_1.default.isBlock(v)
                    ? v
                    : typescript_1.default.factory.createExpressionStatement(v);
            };
            var statements = unions.map(function (u) {
                return typescript_1.default.factory.createIfStatement(u.is(), converter(u.value()));
            });
            return typescript_1.default.factory.createBlock(statements, true);
        };
    };
    var decode_tuple = function (project, importer) {
        return function (input, tuple, explore) {
            var children = tuple
                .map(function (elem, index) { return [elem, index]; })
                .filter(function (_a) {
                var _b = __read(_a, 1), elem = _b[0];
                return filter(elem) && elem.rest === null;
            })
                .map(function (_a) {
                var _b = __read(_a, 2), elem = _b[0], index = _b[1];
                return decode(project, importer)(typescript_1.default.factory.createElementAccessExpression(input, index), elem, __assign(__assign({}, explore), { from: "array" }));
            });
            var rest = (function () {
                if (tuple.length === 0)
                    return null;
                var last = tuple[tuple.length - 1];
                var rest = last.rest;
                if (rest === null || filter(rest) === false)
                    return null;
                return decode(project, importer)(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "slice"), undefined, [typescript_1.default.factory.createNumericLiteral(tuple.length - 1)]), (function () {
                    var wrapper = Metadata_1.Metadata.initialize();
                    wrapper.arrays.push(rest);
                    return wrapper;
                })(), __assign(__assign({}, explore), { start: tuple.length - 1 }));
            })();
            return PruneJoiner_1.PruneJoiner.tuple(children, rest);
        };
    };
    var decode_array = function (project, importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_array(CONFIG(project, importer), importer, PruneJoiner_1.PruneJoiner.array);
    };
    var decode_object = function (importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_object({
            trace: false,
            path: false,
            functors: FUNCTORS,
        })(importer);
    };
    var explore_arrays = function (project, importer) {
        return UnionExplorer_1.UnionExplorer.array({
            checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
            decoder: decode_array(project, importer),
            empty: typescript_1.default.factory.createReturnStatement(),
            success: typescript_1.default.factory.createTrue(),
            failure: function (input, expected) {
                return create_throw_error(importer, input, expected);
            },
        });
    };
    var explore_objects = function (importer) {
        return function (input, meta, explore) {
            if (meta.objects.length === 1)
                return decode_object(importer)(input, meta.objects[0], explore);
            return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("".concat(UNIONERS).concat(meta.union_index)), undefined, [input]);
        };
    };
    var filter = function (meta) {
        return meta.any === false &&
            (meta.objects.length !== 0 ||
                meta.tuples.some(function (t) { return t.some(function (e) { var _a; return filter((_a = e.rest) !== null && _a !== void 0 ? _a : e); }); }) ||
                meta.arrays.some(function (e) { return filter(e); }));
    };
    var FUNCTORS = "$po";
    var UNIONERS = "$pu";
    var CONFIG = function (project, importer) { return ({
        types: {
            input: function (type, name) {
                return typescript_1.default.factory.createTypeReferenceNode(name !== null && name !== void 0 ? name : TypeFactory_1.TypeFactory.getFullName(project.checker, type));
            },
            output: function () { return TypeFactory_1.TypeFactory.keyword("void"); },
        },
        functors: FUNCTORS,
        unioners: UNIONERS,
        trace: false,
        path: false,
        initializer: initializer,
        decoder: decode(project, importer),
        objector: OBJECTOR(project, importer),
    }); };
    var OBJECTOR = function (project, importer) { return ({
        checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
        decoder: decode_object(importer),
        joiner: PruneJoiner_1.PruneJoiner.object,
        unionizer: (0, decode_union_object_1.decode_union_object)(IsProgrammer_1.IsProgrammer.decode_object(importer))(decode_object(importer))(function (exp) { return exp; })(function (value, expected) {
            return create_throw_error(importer, value, expected);
        }),
        failure: function (input, expected) {
            return create_throw_error(importer, input, expected);
        },
    }); };
    var initializer = function (_a, type) {
        var checker = _a.checker;
        var collection = new MetadataCollection_1.MetadataCollection();
        var meta = MetadataFactory_1.MetadataFactory.generate(checker, collection, type, {
            resolve: false,
            constant: true,
        });
        return [collection, meta];
    };
    var create_throw_error = function (importer, value, expected) {
        return typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(importer.use("throws"), [], [
            typescript_1.default.factory.createObjectLiteralExpression([
                typescript_1.default.factory.createPropertyAssignment("expected", typescript_1.default.factory.createStringLiteral(expected)),
                typescript_1.default.factory.createPropertyAssignment("value", value),
            ], true),
        ]));
    };
})(PruneProgrammer = exports.PruneProgrammer || (exports.PruneProgrammer = {}));
//# sourceMappingURL=PruneProgrammer.js.map