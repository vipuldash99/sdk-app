"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertProgrammer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var IdentifierFactory_1 = require("../factories/IdentifierFactory");
var TypeFactory_1 = require("../factories/TypeFactory");
var CheckerProgrammer_1 = require("./CheckerProgrammer");
var IsProgrammer_1 = require("./IsProgrammer");
var FunctionImporeter_1 = require("./helpers/FunctionImporeter");
var OptionPredicator_1 = require("./helpers/OptionPredicator");
var check_object_1 = require("./internal/check_object");
var AssertProgrammer;
(function (AssertProgrammer) {
    AssertProgrammer.generate = function (project, modulo, equals) {
        if (equals === void 0) { equals = false; }
        return function (type, name) {
            var importer = new FunctionImporeter_1.FunctionImporter();
            var program = CheckerProgrammer_1.CheckerProgrammer.generate(project, {
                functors: "$ao",
                unioners: "$au",
                path: true,
                trace: true,
                numeric: OptionPredicator_1.OptionPredicator.numeric(project.options),
                equals: equals,
                combiner: combiner(equals)(importer),
                joiner: joiner(equals)(importer),
                success: typescript_1.default.factory.createTrue(),
            }, importer)(type, name);
            return typescript_1.default.factory.createArrowFunction(undefined, undefined, [
                IdentifierFactory_1.IdentifierFactory.parameter("input", TypeFactory_1.TypeFactory.keyword("any")),
            ], typescript_1.default.factory.createTypeReferenceNode(name !== null && name !== void 0 ? name : TypeFactory_1.TypeFactory.getFullName(project.checker, type)), undefined, typescript_1.default.factory.createBlock(__spreadArray(__spreadArray([], __read(importer.declare(modulo)), false), [
                typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(program, undefined, [
                    typescript_1.default.factory.createIdentifier("input"),
                    typescript_1.default.factory.createStringLiteral("$input"),
                    typescript_1.default.factory.createTrue(),
                ])),
                typescript_1.default.factory.createReturnStatement(typescript_1.default.factory.createIdentifier("input")),
            ], false), true));
        };
    };
    var combiner = function (equals) {
        return function (importer) {
            return function (explore) {
                if (explore.tracable === false)
                    return IsProgrammer_1.IsProgrammer.CONFIG({
                        object: assert_object(equals)(importer),
                        numeric: true,
                    })(importer).combiner(explore);
                var path = explore.postfix
                    ? "_path + ".concat(explore.postfix)
                    : "_path";
                return function (logic) { return function (input, binaries, expected) {
                    return logic === "and"
                        ? binaries
                            .map(function (binary) {
                            return binary.combined
                                ? binary.expression
                                : typescript_1.default.factory.createLogicalOr(binary.expression, create_guard_call(importer)(explore.source === "top"
                                    ? typescript_1.default.factory.createTrue()
                                    : typescript_1.default.factory.createIdentifier("_exceptionable"))(typescript_1.default.factory.createIdentifier(path), expected, input));
                        })
                            .reduce(typescript_1.default.factory.createLogicalAnd)
                        : (function () {
                            var addicted = binaries.slice();
                            if (addicted[addicted.length - 1].combined === false) {
                                addicted.push({
                                    combined: true,
                                    expression: create_guard_call(importer)(explore.source === "top"
                                        ? typescript_1.default.factory.createTrue()
                                        : typescript_1.default.factory.createIdentifier("_exceptionable"))(typescript_1.default.factory.createIdentifier(path), expected, input),
                                });
                            }
                            return addicted
                                .map(function (b) { return b.expression; })
                                .reduce(typescript_1.default.factory.createLogicalOr);
                        })();
                }; };
            };
        };
    };
    var assert_object = function (equals) { return function (importer) {
        return (0, check_object_1.check_object)({
            equals: equals,
            assert: true,
            undefined: true,
            reduce: typescript_1.default.factory.createLogicalAnd,
            positive: typescript_1.default.factory.createTrue(),
            superfluous: function (value) {
                return create_guard_call(importer)()(typescript_1.default.factory.createAdd(typescript_1.default.factory.createIdentifier("_path"), typescript_1.default.factory.createCallExpression(importer.use("join"), undefined, [typescript_1.default.factory.createIdentifier("key")])), "undefined", value);
            },
            halt: function (expr) {
                return typescript_1.default.factory.createLogicalOr(typescript_1.default.factory.createStrictEquality(typescript_1.default.factory.createFalse(), typescript_1.default.factory.createIdentifier("_exceptionable")), expr);
            },
        })(importer);
    }; };
    var joiner = function (equals) {
        return function (importer) { return ({
            object: assert_object(equals)(importer),
            array: function (input, arrow) {
                return typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "every"), undefined, [arrow]);
            },
            failure: function (value, expected, explore) {
                return create_guard_call(importer)((explore === null || explore === void 0 ? void 0 : explore.from) === "top"
                    ? typescript_1.default.factory.createTrue()
                    : typescript_1.default.factory.createIdentifier("_exceptionable"))(typescript_1.default.factory.createIdentifier((explore === null || explore === void 0 ? void 0 : explore.postfix)
                    ? "_path + ".concat(explore.postfix)
                    : "_path"), expected, value);
            },
            full: equals
                ? undefined
                : function (condition) { return function (input, expected, explore) {
                    return typescript_1.default.factory.createLogicalOr(condition, create_guard_call(importer)(explore.from === "top"
                        ? typescript_1.default.factory.createTrue()
                        : typescript_1.default.factory.createIdentifier("_exceptionable"))(typescript_1.default.factory.createIdentifier("_path"), expected, input));
                }; },
        }); };
    };
    var create_guard_call = function (importer) {
        return function (exceptionable) {
            return function (path, expected, value) {
                return typescript_1.default.factory.createCallExpression(importer.use("guard"), undefined, [
                    exceptionable !== null && exceptionable !== void 0 ? exceptionable : typescript_1.default.factory.createIdentifier("_exceptionable"),
                    typescript_1.default.factory.createObjectLiteralExpression([
                        typescript_1.default.factory.createPropertyAssignment("path", path),
                        typescript_1.default.factory.createPropertyAssignment("expected", typescript_1.default.factory.createStringLiteral(expected)),
                        typescript_1.default.factory.createPropertyAssignment("value", value),
                    ], true),
                ]);
            };
        };
    };
})(AssertProgrammer = exports.AssertProgrammer || (exports.AssertProgrammer = {}));
//# sourceMappingURL=AssertProgrammer.js.map