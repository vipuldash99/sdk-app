import ts from "typescript";
import { IMetadataTag } from "../../metadata/IMetadataTag";
import { Metadata } from "../../metadata/Metadata";
import { MetadataObject } from "../../metadata/MetadataObject";
import { FeatureProgrammer } from "../FeatureProgrammer";
import { check_union_array_like } from "../internal/check_union_array_like";
export declare namespace UnionExplorer {
    interface Decoder<T> {
        (input: ts.Expression, target: T, explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]): ts.Expression;
    }
    type ObjectCombiner = Decoder<MetadataObject[]>;
    const object: (config: FeatureProgrammer.IConfig, level?: number) => (input: ts.Expression, targets: MetadataObject[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    const tuple: (props: check_union_array_like.IProps<Metadata[]>) => (input: ts.Expression, targets: Metadata[][], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    namespace tuple {
        type IProps = check_union_array_like.IProps<Metadata | Metadata[]>;
    }
    const array: (props: array.IProps) => (input: ts.Expression, targets: Metadata[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    namespace array {
        type IProps = check_union_array_like.IProps<Metadata>;
    }
    const array_or_tuple: (props: array_or_tuple.IProps) => (input: ts.Expression, targets: (Metadata | Metadata[])[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    namespace array_or_tuple {
        type IProps = check_union_array_like.IProps<Metadata | Metadata[]>;
    }
    const set: (props: set.IProps) => (input: ts.Expression, targets: Metadata[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    namespace set {
        type IProps = check_union_array_like.IProps<Metadata>;
    }
    const map: (props: map.IProps) => (input: ts.Expression, targets: [Metadata, Metadata][], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[]) => ts.Expression;
    namespace map {
        type IProps = check_union_array_like.IProps<[
            Metadata,
            Metadata
        ]>;
    }
}
