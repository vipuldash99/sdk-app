"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloneProgrammer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var ExpressionFactory_1 = require("../factories/ExpressionFactory");
var IdentifierFactory_1 = require("../factories/IdentifierFactory");
var MetadataCollection_1 = require("../factories/MetadataCollection");
var MetadataFactory_1 = require("../factories/MetadataFactory");
var TypeFactory_1 = require("../factories/TypeFactory");
var Metadata_1 = require("../metadata/Metadata");
var FeatureProgrammer_1 = require("./FeatureProgrammer");
var IsProgrammer_1 = require("./IsProgrammer");
var CloneJoiner_1 = require("./helpers/CloneJoiner");
var FunctionImporeter_1 = require("./helpers/FunctionImporeter");
var UnionExplorer_1 = require("./helpers/UnionExplorer");
var decode_union_object_1 = require("./internal/decode_union_object");
var CloneProgrammer;
(function (CloneProgrammer) {
    function generate(project, modulo) {
        var importer = new FunctionImporeter_1.FunctionImporter();
        return FeatureProgrammer_1.FeatureProgrammer.generate(project, CONFIG(project, importer), importer, function (collection) {
            var isFunctors = IsProgrammer_1.IsProgrammer.generate_functors(project, importer)(collection);
            var isUnioners = IsProgrammer_1.IsProgrammer.generate_unioners(project, importer)(collection);
            return __spreadArray(__spreadArray(__spreadArray([], __read(importer.declare(modulo)), false), __read(isFunctors.filter(function (_, i) {
                return importer.hasLocal("$io".concat(i));
            })), false), __read(isUnioners.filter(function (_, i) {
                return importer.hasLocal("$iu".concat(i));
            })), false);
        });
    }
    CloneProgrammer.generate = generate;
    var decode = function (project, importer) {
        return function (input, meta, explore) {
            var e_1, _a, e_2, _b, e_3, _c;
            if (meta.any ||
                meta.arrays.some(function (a) { return a.any; }) ||
                meta.tuples.some(function (t) { return t.every(function (e) { return e.any; }); }))
                return typescript_1.default.factory.createCallExpression(importer.use("any"), undefined, [input]);
            var unions = [];
            if (meta.resolved !== null)
                unions.push({
                    type: "resolved",
                    is: function () { return IsProgrammer_1.IsProgrammer.decode_to_json(input, true); },
                    value: function () {
                        return decode_to_json(project, importer)(input, meta.resolved, explore);
                    },
                });
            var _loop_1 = function (tuple) {
                unions.push({
                    type: "tuple",
                    is: function () {
                        return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                            var partial = Metadata_1.Metadata.initialize();
                            partial.tuples.push(tuple);
                            return partial;
                        })(), explore, []);
                    },
                    value: function () {
                        return decode_tuple(project, importer)(input, tuple, explore);
                    },
                });
            };
            try {
                for (var _d = __values(meta.tuples), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var tuple = _e.value;
                    _loop_1(tuple);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (meta.arrays.length)
                unions.push({
                    type: "array",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isArray(input); },
                    value: function () {
                        return explore_arrays(project, importer)(input, meta.arrays, __assign(__assign({}, explore), { from: "array" }), []);
                    },
                });
            if (meta.sets.length)
                unions.push({
                    type: "set",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Set"); },
                    value: function () { return typescript_1.default.factory.createIdentifier("{}"); },
                });
            if (meta.maps.length)
                unions.push({
                    type: "map",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Map"); },
                    value: function () { return typescript_1.default.factory.createIdentifier("{}"); },
                });
            var _loop_2 = function (native) {
                unions.push({
                    type: "native",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, native); },
                    value: function () {
                        return native === "Boolean" ||
                            native === "Number" ||
                            native === "String"
                            ? typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "valueOf"), undefined, undefined)
                            : typescript_1.default.factory.createIdentifier("{}");
                    },
                });
            };
            try {
                for (var _f = __values(meta.natives), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var native = _g.value;
                    _loop_2(native);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (meta.objects.length)
                unions.push({
                    type: "object",
                    is: function () {
                        return ExpressionFactory_1.ExpressionFactory.isObject(input, {
                            checkNull: true,
                            checkArray: false,
                        });
                    },
                    value: function () {
                        return explore_objects(importer)(input, meta, __assign(__assign({}, explore), { from: "object" }));
                    },
                });
            var last = input;
            try {
                for (var _h = __values(unions.reverse()), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var u = _j.value;
                    last = typescript_1.default.factory.createConditionalExpression(u.is(), undefined, u.value(), undefined, last);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return typescript_1.default.factory.createAsExpression(last, TypeFactory_1.TypeFactory.keyword("any"));
        };
    };
    var decode_to_json = function (project, importer) {
        return function (input, resolved, explore) {
            return decode(project, importer)(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "toJSON"), undefined, []), resolved, explore);
        };
    };
    var decode_tuple = function (project, importer) {
        return function (input, tuple, explore) {
            var children = tuple
                .filter(function (m) { return m.rest === null; })
                .map(function (elem, index) {
                return decode(project, importer)(typescript_1.default.factory.createElementAccessExpression(input, index), elem, __assign(__assign({}, explore), { from: "array" }));
            });
            var rest = (function () {
                if (tuple.length === 0)
                    return null;
                var last = tuple[tuple.length - 1];
                var rest = last.rest;
                if (rest === null)
                    return null;
                return decode(project, importer)(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "slice"), undefined, [typescript_1.default.factory.createNumericLiteral(tuple.length - 1)]), (function () {
                    var wrapper = Metadata_1.Metadata.initialize();
                    wrapper.arrays.push(rest);
                    return wrapper;
                })(), __assign(__assign({}, explore), { start: tuple.length - 1 }));
            })();
            return CloneJoiner_1.CloneJoiner.tuple(children, rest);
        };
    };
    var decode_array = function (project, importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_array(CONFIG(project, importer), importer, CloneJoiner_1.CloneJoiner.array);
    };
    var decode_object = function (importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_object({
            trace: false,
            path: false,
            functors: FUNCTORS,
        })(importer);
    };
    var explore_arrays = function (project, importer) {
        return UnionExplorer_1.UnionExplorer.array({
            checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
            decoder: decode_array(project, importer),
            empty: typescript_1.default.factory.createReturnStatement(),
            success: typescript_1.default.factory.createTrue(),
            failure: function (input, expected) {
                return create_throw_error(importer, input, expected);
            },
        });
    };
    var explore_objects = function (importer) {
        return function (input, meta, explore) {
            if (meta.objects.length === 1)
                return decode_object(importer)(input, meta.objects[0], explore);
            return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("".concat(UNIONERS).concat(meta.union_index)), undefined, [input]);
        };
    };
    var FUNCTORS = "$co";
    var UNIONERS = "$cu";
    var CONFIG = function (project, importer) { return ({
        types: {
            input: function (type, name) {
                return typescript_1.default.factory.createTypeReferenceNode(name !== null && name !== void 0 ? name : TypeFactory_1.TypeFactory.getFullName(project.checker, type));
            },
            output: function (type, name) {
                return typescript_1.default.factory.createTypeReferenceNode("typia.Primitive<".concat(name !== null && name !== void 0 ? name : TypeFactory_1.TypeFactory.getFullName(project.checker, type), ">"));
            },
        },
        functors: FUNCTORS,
        unioners: UNIONERS,
        trace: false,
        path: false,
        initializer: initializer,
        decoder: decode(project, importer),
        objector: OBJECTOR(project, importer),
    }); };
    var OBJECTOR = function (project, importer) { return ({
        checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
        decoder: decode_object(importer),
        joiner: CloneJoiner_1.CloneJoiner.object,
        unionizer: (0, decode_union_object_1.decode_union_object)(IsProgrammer_1.IsProgrammer.decode_object(importer))(decode_object(importer))(function (exp) { return exp; })(function (value, expected) {
            return create_throw_error(importer, value, expected);
        }),
        failure: function (input, expected) {
            return create_throw_error(importer, input, expected);
        },
    }); };
    var initializer = function (_a, type) {
        var checker = _a.checker;
        var collection = new MetadataCollection_1.MetadataCollection();
        var meta = MetadataFactory_1.MetadataFactory.generate(checker, collection, type, {
            resolve: true,
            constant: true,
        });
        return [collection, meta];
    };
    var create_throw_error = function (importer, value, expected) {
        return typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(importer.use("throws"), [], [
            typescript_1.default.factory.createObjectLiteralExpression([
                typescript_1.default.factory.createPropertyAssignment("expected", typescript_1.default.factory.createStringLiteral(expected)),
                typescript_1.default.factory.createPropertyAssignment("value", value),
            ], true),
        ]));
    };
})(CloneProgrammer = exports.CloneProgrammer || (exports.CloneProgrammer = {}));
//# sourceMappingURL=CloneProgrammer.js.map