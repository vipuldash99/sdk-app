"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringifyProgrammer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var ExpressionFactory_1 = require("../factories/ExpressionFactory");
var IdentifierFactory_1 = require("../factories/IdentifierFactory");
var MetadataCollection_1 = require("../factories/MetadataCollection");
var MetadataFactory_1 = require("../factories/MetadataFactory");
var TypeFactory_1 = require("../factories/TypeFactory");
var ValueFactory_1 = require("../factories/ValueFactory");
var Metadata_1 = require("../metadata/Metadata");
var ArrayUtil_1 = require("../utils/ArrayUtil");
var FeatureProgrammer_1 = require("./FeatureProgrammer");
var IsProgrammer_1 = require("./IsProgrammer");
var AtomicPredicator_1 = require("./helpers/AtomicPredicator");
var FunctionImporeter_1 = require("./helpers/FunctionImporeter");
var OptionPredicator_1 = require("./helpers/OptionPredicator");
var StringifyJoinder_1 = require("./helpers/StringifyJoinder");
var StringifyPredicator_1 = require("./helpers/StringifyPredicator");
var UnionExplorer_1 = require("./helpers/UnionExplorer");
var check_native_1 = require("./internal/check_native");
var decode_union_object_1 = require("./internal/decode_union_object");
var feature_object_entries_1 = require("./internal/feature_object_entries");
var StringifyProgrammer;
(function (StringifyProgrammer) {
    function generate(project, modulo) {
        var importer = new FunctionImporeter_1.FunctionImporter();
        return FeatureProgrammer_1.FeatureProgrammer.generate(project, CONFIG(project, importer), importer, function (collection) {
            var isFunctors = IsProgrammer_1.IsProgrammer.generate_functors(project, importer)(collection);
            var isUnioners = IsProgrammer_1.IsProgrammer.generate_unioners(project, importer)(collection);
            return __spreadArray(__spreadArray(__spreadArray([], __read(importer.declare(modulo)), false), __read(isFunctors.filter(function (_, i) {
                return importer.hasLocal("$io".concat(i));
            })), false), __read(isUnioners.filter(function (_, i) {
                return importer.hasLocal("$iu".concat(i));
            })), false);
        });
    }
    StringifyProgrammer.generate = generate;
    var decode = function (project, importer) {
        return function (input, meta, explore, tags) {
            var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
            if (meta.any === true)
                return wrap_required(input, meta, explore)(wrap_functional(input, meta, explore)(typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("JSON.stringify"), undefined, [input])));
            var size = meta.size();
            if (size === 0 &&
                (meta.required === false || meta.nullable === true)) {
                if (meta.required === false && meta.nullable === true)
                    return explore.from === "array"
                        ? typescript_1.default.factory.createStringLiteral("null")
                        : typescript_1.default.factory.createConditionalExpression(typescript_1.default.factory.createStrictEquality(typescript_1.default.factory.createNull(), input), undefined, typescript_1.default.factory.createStringLiteral("null"), undefined, typescript_1.default.factory.createIdentifier("undefined"));
                else if (meta.required === false)
                    return explore.from === "array"
                        ? typescript_1.default.factory.createStringLiteral("null")
                        : typescript_1.default.factory.createIdentifier("undefined");
                else
                    return typescript_1.default.factory.createStringLiteral("null");
            }
            var unions = [];
            if (meta.resolved !== null)
                if (size === 1)
                    return decode_to_json(project, importer)(input, meta.resolved, explore, tags);
                else
                    unions.push({
                        type: "resolved",
                        is: function () { return IsProgrammer_1.IsProgrammer.decode_to_json(input, false); },
                        value: function () {
                            return decode_to_json(project, importer)(input, meta.resolved, explore, tags);
                        },
                    });
            else if (meta.functional === true)
                unions.push({
                    type: "functional",
                    is: function () { return IsProgrammer_1.IsProgrammer.decode_functional(input); },
                    value: function () { return decode_functional(explore); },
                });
            if (meta.templates.length ||
                ArrayUtil_1.ArrayUtil.has(meta.constants, function (c) { return c.type === "string"; }))
                if (AtomicPredicator_1.AtomicPredicator.template(meta)) {
                    var partial_1 = Metadata_1.Metadata.initialize();
                    partial_1.atomics.push("string"),
                        unions.push({
                            type: "template literal",
                            is: function () {
                                return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, partial_1, explore, []);
                            },
                            value: function () {
                                return decode_atomic(project, importer)(input, "string", explore, tags);
                            },
                        });
                }
            var _loop_1 = function (constant) {
                if (AtomicPredicator_1.AtomicPredicator.constant(meta)(constant.type) === false)
                    return "continue";
                else if (constant.type !== "string")
                    unions.push({
                        type: "atomic",
                        is: function () {
                            return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                                var partial = Metadata_1.Metadata.initialize();
                                partial.atomics.push(constant.type);
                                return partial;
                            })(), explore, []);
                        },
                        value: function () {
                            return decode_atomic(project, importer)(input, constant.type, explore, tags);
                        },
                    });
                else if (meta.templates.length === 0)
                    unions.push({
                        type: "const string",
                        is: function () {
                            return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                                var partial = Metadata_1.Metadata.initialize();
                                partial.atomics.push("string");
                                return partial;
                            })(), explore, []);
                        },
                        value: function () {
                            return decode_constant_string(project, importer)(input, __spreadArray([], __read(constant.values), false), explore);
                        },
                    });
            };
            try {
                for (var _f = __values(meta.constants), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var constant = _g.value;
                    _loop_1(constant);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var _loop_2 = function (type) {
                if (AtomicPredicator_1.AtomicPredicator.atomic(meta)(type))
                    unions.push({
                        type: "atomic",
                        is: function () {
                            return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                                var partial = Metadata_1.Metadata.initialize();
                                partial.atomics.push(type);
                                return partial;
                            })(), explore, []);
                        },
                        value: function () {
                            return decode_atomic(project, importer)(input, type, explore, tags);
                        },
                    });
            };
            try {
                for (var _h = __values(meta.atomics), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var type = _j.value;
                    _loop_2(type);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var _loop_3 = function (tuple) {
                var e_6, _r;
                try {
                    for (var tuple_1 = (e_6 = void 0, __values(tuple)), tuple_1_1 = tuple_1.next(); !tuple_1_1.done; tuple_1_1 = tuple_1.next()) {
                        var child = tuple_1_1.value;
                        if (StringifyPredicator_1.StringifyPredicator.undefindable(meta))
                            throw new Error("Error on typia.stringify(): tuple cannot contain undefined value - (".concat(child.getName(), ")."));
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (tuple_1_1 && !tuple_1_1.done && (_r = tuple_1.return)) _r.call(tuple_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                unions.push({
                    type: "tuple",
                    is: function () {
                        return IsProgrammer_1.IsProgrammer.decode(project, importer)(input, (function () {
                            var partial = Metadata_1.Metadata.initialize();
                            partial.tuples.push(tuple);
                            return partial;
                        })(), explore, []);
                    },
                    value: function () {
                        return decode_tuple(project, importer)(input, tuple, explore, tags);
                    },
                });
            };
            try {
                for (var _k = __values(meta.tuples), _l = _k.next(); !_l.done; _l = _k.next()) {
                    var tuple = _l.value;
                    _loop_3(tuple);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (meta.arrays.length) {
                try {
                    for (var _m = __values(meta.arrays), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var child = _o.value;
                        if (StringifyPredicator_1.StringifyPredicator.undefindable(child))
                            throw new Error("Error on typia.stringify(): array cannot contain undefined value (".concat(child.getName(), ")."));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                var value = meta.arrays.some(function (elem) { return elem.any; })
                    ? function () {
                        return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("JSON.stringify"), undefined, [input]);
                    }
                    : function () {
                        return explore_arrays(project, importer)(input, meta.arrays, __assign(__assign({}, explore), { from: "array" }), []);
                    };
                unions.push({
                    type: "array",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isArray(input); },
                    value: value,
                });
            }
            if (meta.natives.length) {
                var _loop_4 = function (native) {
                    unions.push({
                        type: "object",
                        is: function () { return (0, check_native_1.check_native)(native)(input); },
                        value: function () {
                            return AtomicPredicator_1.AtomicPredicator.native(native)
                                ? decode_atomic(project, importer)(input, native.toLowerCase(), explore, tags)
                                : typescript_1.default.factory.createStringLiteral("{}");
                        },
                    });
                };
                try {
                    for (var _p = __values(meta.natives), _q = _p.next(); !_q.done; _q = _p.next()) {
                        var native = _q.value;
                        _loop_4(native);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            if (meta.sets.length)
                unions.push({
                    type: "object",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Set"); },
                    value: function () { return typescript_1.default.factory.createStringLiteral("{}"); },
                });
            if (meta.maps.length)
                unions.push({
                    type: "object",
                    is: function () { return ExpressionFactory_1.ExpressionFactory.isInstanceOf(input, "Map"); },
                    value: function () { return typescript_1.default.factory.createStringLiteral("{}"); },
                });
            if (meta.objects.length)
                unions.push({
                    type: "object",
                    is: function () {
                        return ExpressionFactory_1.ExpressionFactory.isObject(input, {
                            checkNull: true,
                            checkArray: meta.objects.some(function (obj) {
                                return obj.properties.every(function (prop) {
                                    return !prop.key.isSoleLiteral() ||
                                        !prop.value.required;
                                });
                            }),
                        });
                    },
                    value: function () {
                        return meta.isParentResolved() === false &&
                            meta.objects.length === 1 &&
                            meta.objects[0]._Is_simple()
                            ? (function () {
                                var obj = meta.objects[0];
                                var entries = (0, feature_object_entries_1.feature_object_entries)({
                                    decoder: decode(project, importer),
                                    trace: false,
                                    path: false,
                                })(importer)(obj)(input);
                                return StringifyJoinder_1.StringifyJoiner.object(importer)(input, entries);
                            })()
                            : explore_objects(importer)(input, meta, __assign(__assign({}, explore), { from: "object" }));
                    },
                });
            var wrapper = function (output) {
                return wrap_required(input, meta, explore)(wrap_nullable(input, meta)(output));
            };
            if (unions.length === 0)
                return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("JSON.stringify"), undefined, [input]);
            else if (unions.length === 1)
                return wrapper(unions[0].value());
            return wrapper(typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createArrowFunction(undefined, undefined, [], undefined, undefined, iterate(importer, input, unions, meta.getName())), undefined, undefined));
        };
    };
    var decode_array = function (project, importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_array(CONFIG(project, importer), importer, StringifyJoinder_1.StringifyJoiner.array);
    };
    var decode_object = function (importer) {
        return FeatureProgrammer_1.FeatureProgrammer.decode_object({
            trace: false,
            path: false,
            functors: FUNCTORS,
        })(importer);
    };
    var decode_tuple = function (project, importer) {
        return function (input, tuple, explore, tags) {
            var children = tuple
                .filter(function (elem) { return elem.rest === null; })
                .map(function (elem, index) {
                return decode(project, importer)(typescript_1.default.factory.createElementAccessExpression(input, index), elem, __assign(__assign({}, explore), { from: "array" }), tags);
            });
            var rest = (function () {
                if (tuple.length === 0)
                    return null;
                var last = tuple[tuple.length - 1];
                if (last.rest === null)
                    return null;
                var code = decode(project, importer)(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "slice"), undefined, [typescript_1.default.factory.createNumericLiteral(tuple.length - 1)]), (function () {
                    var wrapper = Metadata_1.Metadata.initialize();
                    wrapper.arrays.push(tuple[tuple.length - 1].rest);
                    return wrapper;
                })(), __assign(__assign({}, explore), { start: tuple.length - 1 }), tags);
                return typescript_1.default.factory.createCallExpression(importer.use("rest"), undefined, [code]);
            })();
            return StringifyJoinder_1.StringifyJoiner.tuple(children, rest);
        };
    };
    var decode_atomic = function (project, importer) {
        return function (input, type, explore, tagList) {
            if (type === "string")
                if (tagList.find(function (tag) { return tag.kind === "format"; }) !== undefined)
                    return [
                        typescript_1.default.factory.createStringLiteral('"'),
                        input,
                        typescript_1.default.factory.createStringLiteral('"'),
                    ].reduce(function (x, y) { return typescript_1.default.factory.createAdd(x, y); });
                else
                    return typescript_1.default.factory.createCallExpression(importer.use("string"), undefined, [input]);
            else if (type === "number" &&
                OptionPredicator_1.OptionPredicator.numeric(project.options))
                input = typescript_1.default.factory.createCallExpression(importer.use("number"), undefined, [input]);
            return explore.from !== "top"
                ? input
                : typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "toString"), undefined, undefined);
        };
    };
    var decode_constant_string = function (project, importer) {
        return function (input, values, explore) {
            if (values.every(function (v) { return !StringifyPredicator_1.StringifyPredicator.require_escape(v); }))
                return [
                    typescript_1.default.factory.createStringLiteral('"'),
                    input,
                    typescript_1.default.factory.createStringLiteral('"'),
                ].reduce(function (x, y) { return typescript_1.default.factory.createAdd(x, y); });
            else
                return decode_atomic(project, importer)(input, "string", explore, []);
        };
    };
    var decode_to_json = function (project, importer) {
        return function (input, resolved, explore, tags) {
            return decode(project, importer)(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.join(input, "toJSON"), undefined, []), resolved, explore, tags);
        };
    };
    function decode_functional(explore) {
        return explore.from === "array"
            ? typescript_1.default.factory.createStringLiteral("null")
            : typescript_1.default.factory.createIdentifier("undefined");
    }
    var explore_arrays = function (project, importer) {
        return UnionExplorer_1.UnionExplorer.array({
            checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
            decoder: decode_array(project, importer),
            empty: typescript_1.default.factory.createStringLiteral("[]"),
            success: typescript_1.default.factory.createTrue(),
            failure: function (input, expected) {
                return create_throw_error(importer, input, expected);
            },
        });
    };
    var explore_objects = function (importer) {
        return function (input, meta, explore) {
            if (meta.objects.length === 1)
                return decode_object(importer)(input, meta.objects[0], explore);
            return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("".concat(UNIONERS).concat(meta.union_index)), undefined, [input]);
        };
    };
    function wrap_required(input, meta, explore) {
        if (meta.required === true && meta.any === false)
            return function (expression) { return expression; };
        return function (expression) {
            return typescript_1.default.factory.createConditionalExpression(typescript_1.default.factory.createStrictInequality(typescript_1.default.factory.createIdentifier("undefined"), input), undefined, expression, undefined, explore.from === "array"
                ? typescript_1.default.factory.createStringLiteral("null")
                : typescript_1.default.factory.createIdentifier("undefined"));
        };
    }
    function wrap_nullable(input, meta) {
        if (meta.nullable === false)
            return function (expression) { return expression; };
        return function (expression) {
            return typescript_1.default.factory.createConditionalExpression(typescript_1.default.factory.createStrictInequality(typescript_1.default.factory.createNull(), input), undefined, expression, undefined, typescript_1.default.factory.createStringLiteral("null"));
        };
    }
    function wrap_functional(input, meta, explore) {
        if (meta.functional === false)
            return function (expression) { return expression; };
        return function (expression) {
            return typescript_1.default.factory.createConditionalExpression(typescript_1.default.factory.createStrictInequality(typescript_1.default.factory.createStringLiteral("function"), ValueFactory_1.ValueFactory.TYPEOF(input)), undefined, expression, undefined, decode_functional(explore));
        };
    }
    var iterate = function (importer, input, unions, expected) {
        return typescript_1.default.factory.createBlock(__spreadArray(__spreadArray([], __read(unions.map(function (u) {
            return typescript_1.default.factory.createIfStatement(u.is(), typescript_1.default.factory.createReturnStatement(u.value()));
        })), false), [
            create_throw_error(importer, input, expected),
        ], false), true);
    };
    var FUNCTORS = "$so";
    var UNIONERS = "$su";
    var CONFIG = function (project, importer) { return ({
        types: {
            input: function (type, name) {
                return typescript_1.default.factory.createTypeReferenceNode(name !== null && name !== void 0 ? name : TypeFactory_1.TypeFactory.getFullName(project.checker, type));
            },
            output: function () { return TypeFactory_1.TypeFactory.keyword("string"); },
        },
        functors: FUNCTORS,
        unioners: UNIONERS,
        trace: false,
        path: false,
        initializer: initializer,
        decoder: decode(project, importer),
        objector: OBJECTOR(project, importer),
    }); };
    var initializer = function (_a, type) {
        var checker = _a.checker;
        var collection = new MetadataCollection_1.MetadataCollection();
        var meta = MetadataFactory_1.MetadataFactory.generate(checker, collection, type, {
            resolve: true,
            constant: true,
            validate: function (meta) {
                if (meta.atomics.find(function (str) { return str === "bigint"; }))
                    throw new Error(NO_BIGINT);
            },
        });
        return [collection, meta];
    };
    var OBJECTOR = function (project, importer) { return ({
        checker: IsProgrammer_1.IsProgrammer.decode(project, importer),
        decoder: decode_object(importer),
        joiner: StringifyJoinder_1.StringifyJoiner.object(importer),
        unionizer: (0, decode_union_object_1.decode_union_object)(IsProgrammer_1.IsProgrammer.decode_object(importer))(decode_object(importer))(function (exp) { return exp; })(function (value, expected) {
            return create_throw_error(importer, value, expected);
        }),
        failure: function (input, expected) {
            return create_throw_error(importer, input, expected);
        },
    }); };
    function create_throw_error(importer, value, expected) {
        return typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(importer.use("throws"), [], [
            typescript_1.default.factory.createObjectLiteralExpression([
                typescript_1.default.factory.createPropertyAssignment("expected", typescript_1.default.factory.createStringLiteral(expected)),
                typescript_1.default.factory.createPropertyAssignment("value", value),
            ], true),
        ]));
    }
})(StringifyProgrammer = exports.StringifyProgrammer || (exports.StringifyProgrammer = {}));
var NO_BIGINT = "Error on typia.stringify(): does not allow bigint type.";
//# sourceMappingURL=StringifyProgrammer.js.map